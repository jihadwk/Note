#coding=UTF-8
#身份证号码编码方式和校验算法
# 1 身份证号码的字段构成：

# 地址码

# 身份证前六位,表示户口所在县（市、旗、区）的行政区划代码。

# 生日码

# 身份证第七至第十四位,表示出生的年、月、日。

# 顺序码

# 身份证十五到十七位,为同一地址码所标识的区域范围内，对同年、月、日出生的人员编订的顺序号。其中第十七位奇数分给男性，偶数分给女性。

# 校验码

# 身份证最后一位,根据前面十七位数字码，按照ISO7064：1983.MOD11-2计算出来的校验码。作为尾号的校验码，是由号码编制单位按统一的公式计算出来的，如果某人的尾号是0-9，都不会出现X，但如果尾号是10，那就用X替代，因为如果用10作尾号，此人的身份证号码就变成了19位，为了身份证号码数位的一致性，用罗马字母X替代10。

# 2 校验码具体的计算方法

# 将前面的身份证号码17位数分别乘以不同的系数。第i位对应的数为[2^(18-i)]mod11。从第一位到第十七位的系数分别为：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2 .

# 将这17位数字和系数相乘的结果相加.

# 用加出来的和除以11，看余数是多少.

# 余数只可能有0 1 2 3 4 5 6 7 8 9 10这11个数字。其分别对应的最后一位身份证的号码为1 0 X 9 8 7 6 5 4 3 2；

# 通过上面得知如果余数是2，就会在身份证的第18位数字上出现罗马数字的Ⅹ。如果余数是10，身份证的最后一位号码就是2.
def check_id_num(num): #num字符串
	if len(num)!=18: #号码长度18位
		return False
	if not num[:-1].isdigit():#前17位是不是数字
		return False
	fact = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]
	sum = 0
	for i in range(17):
		sum+=int(num[i])*fact[i]
	m=sum%11
	chk='10X98765432'
	print '最后一位是',chk[m]
	if chk[m]==num[-1]:
		return True
	return False

#test
s='343125199310213613'
if check_id_num(s):
        print u'有效的身份证'
else:
        print u'无效的证件号'
        
